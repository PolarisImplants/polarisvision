<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Polaris Vision ‚Äî Mesure de coordonn√©es (calibration + test)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body{margin:0;background:#285FF4;color:#e5e7eb;font-family:system-ui;}
    .card{background:#111827;padding:12px;border-radius:10px;margin:10px;}
    table{width:100%;border-collapse:collapse;color:#fff;font-size:14px;}
    table th,table td{border:1px solid #444;padding:4px;text-align:center;}
    button{background:#285FF4;color:white;border:1px solid #1f2937;padding:6px 12px;border-radius:8px;cursor:pointer;}
    canvas{background:#285FF4;border:1px dashed #253049;border-radius:10px;}

    /* Curseur cruciforme pendant calibration */
    .calibrating-cursor {
      cursor: crosshair !important;
    }

    .subbuttons {
      margin-top:8px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>

<body>

  <h2 style="padding:10px">Polaris Vision ‚Äî Pack Complet (calibration X + Y avec test)</h2>

  <div class="card">
    <input type="file" id="file" accept="image/*">
    <button id="calibrate4">Calibrer (4 points)</button>
    <div class="subbuttons">
      <button id="testCalib">Tester la calibration</button>
      <button id="validateCalib">Valider la calibration</button>
      <button id="cancelCalib">Annuler calibration</button>
    </div>
    <button id="clearAll">Effacer tous les points</button>
    <button id="exportPDF">Exporter PDF (image + tableau)</button><div class="card" style="margin-top:20px">
  <details>
    <summary style="cursor:pointer; font-weight:600;">
      üìê Tol√©rances de pr√©cision ‚Äì R√©f√©rence
    </summary>

    <p style="margin-top:10px; font-size:14px;">
      D√©viation th√©orique de l‚Äôaxe de forage en fonction d‚Äôune erreur de clic
      sur les plaques Polaris (point rouge / bleu).
    </p>

    <table style="width:100%; border-collapse:collapse; margin-top:10px;">
      <tr>
        <th>Erreur de clic (mm)</th>
        <th>Puits 10 mm</th>
        <th>Puits 11 mm</th>
        <th>Puits 13 mm</th>
      </tr>
      <tr>
        <td>0,10 mm</td><td>0,17 mm</td><td>0,19 mm</td><td>0,22 mm</td>
      </tr>
      <tr>
        <td>0,20 mm</td><td>0,35 mm</td><td>0,38 mm</td><td>0,45 mm</td>
      </tr>
      <tr>
        <td>0,30 mm</td><td>0,52 mm</td><td>0,58 mm</td><td>0,67 mm</td>
      </tr>
    </table>

    <p style="margin-top:10px; font-size:13px;">
      <b>Recommandations :</b><br>
      ‚Ä¢ Privil√©gier un centrage visuel pr√©cis du clic<br>
      ‚Ä¢ Erreur ‚â§ 0,1 mm cliniquement acceptable<br>
      ‚Ä¢ &gt; 0,3 mm : v√©rification de l‚Äôaxe recommand√©e
    </p>
  </details>
</div>



</button><button id="exportPDF11">
  Export PDF 1:1
</button>
 <button id="exportGcode">Exporter G-code</button>
  </div>

  <div class="card" style="display:flex;gap:10px">
    <canvas id="cv" width="800" height="560"></canvas>
    <canvas id="mag" width="160" height="160"></canvas>
  </div>

  <div class="card" style="background:#f6f9ff;border:1px solid #b9c8e6;padding:10px;margin-bottom:15px; color:#000;">
    <h3>Param√®tres CNC</h3>
    <label>Profondeur Z (mm): <input id="zDepth" type="number" step="0.01" value="1.75"></label><br>
    <label>Z s√©curit√© (mm): <input id="zSafe" type="number" step="0.1" value="4"></label><br>
    <label>Vitesse S (tr/min): <input id="speed" type="number" step="10" value="1200"></label><br>
    <label><input id="traversant" type="checkbox"> Per√ßage traversant</label><br>
    <label>√âpaisseur plaque (mm): <input id="thickness" type="number" step="0.01" value="1.78"></label><br>
    <button type="button" onclick="restoreDefaults()">Restaurer valeurs recommand√©es</button>
  </div>

    <h3>Points d√©tect√©s</h3>
    <table id="pointsTable">
      <thead>
        <tr>
          <th>#</th>
          <th>Suppr</th>
          <th>x_px</th>
          <th>y_px</th>
          <th>X mm</th>
          <th>Y mm</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

<script>
// ==== CONSTANTES PLAQUE ====
const PLAQUE_WIDTH_MM  = 62.36;
const PLAQUE_HEIGHT_MM = 52.36;

// ==== VARIABLES GLOBALES IMAGE ====
let imgBitmap = null;
let view = { scale:1, offx:0, offy:0 };
let points = [];

// ==== CALIBRATION RECTANGLE ROUGE ====
let activeRect   = null;  // rectangle valid√©
let pendingRect  = null;  // rectangle en test (vert)
let calibPoints  = [];    // 4 clics
let calibrationMode = false;
let testMode = false;     // mode "Tester la calibration" (A)

// ==== CHARGEMENT IMAGE ====
document.getElementById('file').addEventListener('change', e=>{
  const f = e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  const im  = new Image();

  im.onload = async ()=>{
    imgBitmap = await createImageBitmap(im);
    fitAndDraw();
  };
  im.src = url;
});

// ==== CANVAS PRINCIPAL ====
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

function fitContain(W,H,w,h){
  const s = Math.min(W/w, H/h);
  return { scale:s, offx:(W-w*s)/2, offy:(H-h*s)/2 };
}

function fitAndDraw(){
  if(imgBitmap){
    view = fitContain(cv.width, cv.height, imgBitmap.width, imgBitmap.height);
  }
  draw();
}

function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);
  ctx.fillStyle="#285FF4";
  ctx.fillRect(0,0,cv.width,cv.height);

  if(imgBitmap){
    ctx.drawImage(
      imgBitmap,
      view.offx, view.offy,
      imgBitmap.width*view.scale,
      imgBitmap.height*view.scale
    );
  }

  // Dessin du rectangle de calibration en test (vert)
  if(pendingRect){
    ctx.save();
    ctx.strokeStyle = "lime";
    ctx.lineWidth = 2;
    const x = view.offx + pendingRect.left  * view.scale;
    const y = view.offy + pendingRect.top   * view.scale;
    const w = (pendingRect.right  - pendingRect.left) * view.scale;
    const h = (pendingRect.bottom - pendingRect.top ) * view.scale;
    ctx.strokeRect(x,y,w,h);
    ctx.restore();
  }

  // Points mesur√©s
  ctx.fillStyle="yellow";
  ctx.strokeStyle="yellow";
  ctx.font="12px system-ui";

  points.forEach((p,i)=>{
    const cx = view.offx + p.x_px*view.scale;
    const cy = view.offy + p.y_px*view.scale;
    ctx.beginPath();
    ctx.arc(cx,cy,5,0,Math.PI*2);
    ctx.fill();
    ctx.fillText(i+1, cx+8, cy-8);
  });
}

// ==== GESTION DES CLICS SUR LE CANVAS ====
cv.addEventListener('click', e=>{
  if(!imgBitmap) return;

  const r = cv.getBoundingClientRect();
  const xImg = (e.clientX - r.left - view.offx) / view.scale;
  const yImg = (e.clientY - r.top  - view.offy) / view.scale;

  if(calibrationMode){
    handleCalibrationClick(xImg, yImg);
    return;
  }

  if(testMode && pendingRect){
    // Mode TEST : afficher la coordonn√©e, sans enregistrer de point
    const testPt = computePointFromImage(xImg, yImg, /*usePending*/true);
    alert(
      "Test calibration (non valid√©e)\n" +
      "X = " + testPt.x_mm.toFixed(2) + " mm\n" +
      "Y = " + testPt.y_mm.toFixed(2) + " mm"
    );
    return;
  }

  // Mode normal : enregistrement d'un point en utilisant la calibration active (si pr√©sente)
  const pt = computePointFromImage(xImg, yImg, /*usePending*/false);
  points.push(pt);
  updateTable();
  draw();
});

// ==== CALIBRATION 4 POINTS ====
document.getElementById('calibrate4').onclick = ()=>{
  if(!imgBitmap){
    alert("Charge d'abord une image Polaris (PDF converti en image).");
    return;
  }
  calibrationMode = true;
  testMode = false;
  calibPoints = [];
  pendingRect = null;
  cv.classList.add("calibrating-cursor");
  alert("Calibration : cliquez le COIN HAUT GAUCHE du rectangle rouge.");
};

function handleCalibrationClick(xImg, yImg){
  calibPoints.push({x:xImg, y:yImg});
  const n = calibPoints.length;
  if(n===1){
    alert("Cliquez le COIN HAUT DROIT du rectangle rouge.");
  }else if(n===2){
    alert("Cliquez le COIN BAS DROIT du rectangle rouge.");
  }else if(n===3){
    alert("Cliquez le COIN BAS GAUCHE du rectangle rouge.");
  }else if(n===4){
    // On a les 4 points : HG, HD, BD, BG (ordre souhait√©).
    // On calcule le rectangle englobant.
    const xs = calibPoints.map(p=>p.x);
    const ys = calibPoints.map(p=>p.y);
    const left   = Math.min(...xs);
    const right  = Math.max(...xs);
    const top    = Math.min(...ys);
    const bottom = Math.max(...ys);

    if(right <= left || bottom <= top){
      alert("Calibration invalide. Recommencez.");
      calibPoints = [];
      pendingRect = null;
      calibrationMode = false;
      cv.classList.remove("calibrating-cursor");
      draw();
      return;
    }

    pendingRect = { left, right, top, bottom };
    calibrationMode = false;
    cv.classList.remove("calibrating-cursor");
    testMode = false;

    alert(
      "Rectangle de calibration propos√© :\n" +
      "Largeur px = " + (right-left).toFixed(1) + "\n" +
      "Hauteur px = " + (bottom-top).toFixed(1) + "\n\n" +
      "Un cadre VERT vient d'appara√Ætre. V√©rifiez visuellement.\n" +
      "‚Ä¢ Utilisez 'Tester la calibration' pour v√©rifier un point.\n" +
      "‚Ä¢ Puis 'Valider' si tout est bon."
    );
    draw();
  }
}

// ==== BOUTONS A / B / C ====

// A : Tester la calibration
document.getElementById('testCalib').onclick = ()=>{
  if(!pendingRect){
    alert("Aucune calibration en attente. Cliquez d'abord sur 'Calibrer (4 points)'.");
    return;
  }
  testMode = true;
  alert("Mode TEST : cliquez sur un point de l'image.\nLes X/Y mm calcul√©s avec la calibration NON valid√©e s'afficheront.\nRien ne sera enregistr√©.");
};

// B : Valider la calibration
document.getElementById('validateCalib').onclick = ()=>{
  if(!pendingRect){
    alert("Aucune calibration en attente.");
    return;
  }
  activeRect = { ...pendingRect }; // copie
  pendingRect = null;
  calibPoints = [];
  calibrationMode = false;
  testMode = false;
  draw();
  alert("Calibration VALID√âE.\nTous les nouveaux points utiliseront ce rectangle.");
};

// C : Annuler calibration
document.getElementById('cancelCalib').onclick = ()=>{
  pendingRect = null;
  calibPoints = [];
  calibrationMode = false;
  testMode = false;
  cv.classList.remove("calibrating-cursor");
  draw();
  alert("Calibration annul√©e.\nLa calibration pr√©c√©dente (si elle existait) reste active.");
};

// ==== CONVERSION PIXELS ‚Üí MM ====

function computePointFromImage(xImg, yImg, usePending){
  let rectToUse = null;

  if(usePending && pendingRect){
    rectToUse = pendingRect;
  }else if(activeRect){
    rectToUse = activeRect;
  }

  if(!rectToUse){
    // Fallback ancien (0.21 mm/px, origine en 0,0)
    const fallback = 0.21;
    return {
      x_px:xImg,
      y_px:yImg,
      x_mm:xImg * fallback,
      y_mm:PLAQUE_HEIGHT_MM - yImg * fallback
    };
  }

  const rectWidthPx  = rectToUse.right  - rectToUse.left;
  const rectHeightPx = rectToUse.bottom - rectToUse.top;

  const u = (xImg - rectToUse.left) / rectWidthPx;   // 0 ‚Üí 1 en X
  const v = (yImg - rectToUse.top ) / rectHeightPx;  // 0 ‚Üí 1 en Y (haut‚Üíbas)

  const x_mm = u * PLAQUE_WIDTH_MM;
  const y_mm = (1 - v) * PLAQUE_HEIGHT_MM;  // origine en bas √† gauche

  return {
    x_px:xImg,
    y_px:yImg,
    x_mm,
    y_mm
  };
}

// ==== TABLEAU ====
function updateTable(){
  const tbody=document.querySelector("#pointsTable tbody");
  tbody.innerHTML="";
  points.forEach((p,i)=>{
    const tr=document.createElement("tr");
    tr.innerHTML = `
      <td>${i+1}</td>
      <td><button data-del='${i}'>X</button></td>
      <td>${p.x_px.toFixed(1)}</td>
      <td>${p.y_px.toFixed(1)}</td>
      <td>${p.x_mm.toFixed(2)}</td>
      <td>${p.y_mm.toFixed(2)}</td>
    `;
    tbody.appendChild(tr);
  });

  document.querySelectorAll("#pointsTable button[data-del]").forEach(btn=>{
    btn.onclick = e=>{
      const idx=parseInt(btn.dataset.del,10);
      points.splice(idx,1);
      updateTable();
      draw();
    };
  });
}

// ==== PARAM√àTRES CNC ====
function restoreDefaults(){
  document.getElementById('zDepth').value = 1.75;
  document.getElementById('zSafe').value  = 4;
  document.getElementById('speed').value  = 1200;
  document.getElementById('traversant').checked = false;
  document.getElementById('thickness').value = 1.78;
}

// ==== EFFACER TOUS LES POINTS ====
document.getElementById('clearAll').onclick = ()=>{
  points = [];
  updateTable();
  draw();
};

// ==== EXPORT PDF ====
document.getElementById('exportPDF').onclick = async () => {
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ unit: "pt", format: "a4" });
  const pageWidth = pdf.internal.pageSize.getWidth();
  let cursorY = 40;

  if (imgBitmap) {
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width  = imgBitmap.width;
    tempCanvas.height = imgBitmap.height;
    const tctx = tempCanvas.getContext("2d");
    tctx.drawImage(imgBitmap, 0, 0);
    const imgData = tempCanvas.toDataURL("image/png");
    const ratio = imgBitmap.width / imgBitmap.height;
    const displayWidth  = pageWidth - 80;
    const displayHeight = displayWidth / ratio;
    pdf.addImage(imgData, "PNG", 40, cursorY, displayWidth, displayHeight);
    cursorY += displayHeight + 20;
  }

  const depthVal = parseFloat(document.getElementById('zDepth').value || "0").toFixed(2);
  const zsafeVal = document.getElementById('zSafe').value || "4";
  const speedVal = document.getElementById('speed').value || "1200";
  const trav     = document.getElementById('traversant').checked ? "Oui" : "Non";
  const thick    = document.getElementById('thickness').value || "1.78";

  const boxText = [
    "Param√®tres CNC :",
    `Profondeur de forage : ${depthVal} mm`,
    `Valeur G-code : Z = -${depthVal} mm`,
    `Z s√©curit√© : ${zsafeVal} mm`,
    `Vitesse : ${speedVal} tr/min`,
    `Per√ßage traversant : ${trav}`,
    `√âpaisseur plaque : ${thick} mm`,
    "Mode : Peck"
  ];

  const boxX = 40;
  const boxY = cursorY;
  const boxW = pageWidth - 80;
  const boxH = 20 + boxText.length * 16;

  pdf.rect(boxX, boxY, boxW, boxH);
  pdf.setFontSize(12);
  let ty = boxY + 18;
  boxText.forEach(t => { pdf.text(t, boxX + 10, ty); ty += 16; });

  cursorY = boxY + boxH + 30;

  pdf.setFontSize(14);
  pdf.text("Points d√©tect√©s :", 40, cursorY);
  cursorY += 20;

  points.forEach((p, i) => {
    pdf.text(
      `#${i+1} ‚Äî X:${p.x_mm.toFixed(2)}mm  Y:${p.y_mm.toFixed(2)}mm`,
      40, cursorY
    );
    cursorY += 18;
    if (cursorY > 800) {
      pdf.addPage();
      cursorY = 40;
    }
  });

  pdf.save("polaris_points.pdf");
};

// ==== EXPORT G-CODE ====
document.getElementById("exportGcode").onclick = () => {
  let gcode = "";
  gcode += `(Programme PolarisVision)\nG21\nG90\nM3 S${document.getElementById('speed').value}\n`;

  let prof = parseFloat(document.getElementById('zDepth').value);
  if (document.getElementById('traversant').checked){
    let thick = parseFloat(document.getElementById('thickness').value);
    prof = thick + 0.10;
  }
  const profondeur = -prof;
  const zSafe = parseFloat(document.getElementById('zSafe').value);
  const peck = 1;

  points.forEach((p, i) => {
    gcode += `\n(--- Point ${i+1} ---)\nG0 Z${zSafe}\n`;
    gcode += `G0 X${p.x_mm.toFixed(2)} Y${p.y_mm.toFixed(2)}\n`;

    let z = 0;
    while (z > profondeur){
      z = Math.max(z - peck, profondeur);
      gcode += `G1 Z${z.toFixed(2)} F100\n`;
      gcode += `G0 Z${zSafe}\n`;
    }
  });

  gcode += "\nM5\nG0 Z10\nG0 X0 Y0\nM30\n";

  const blob = new Blob([gcode], {type:"text/plain"});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement("a");
  a.href = url;
  a.download = "polaris_points.gcode";
  a.click();
};
</script>
<script>
document.getElementById("exportPDF11").onclick = () => {
  if (!imgBitmap || points.length === 0) {
    alert("Chargez une image et placez au moins un point.");
    return;
  }

  const { jsPDF } = window.jspdf;

  const PLAQUE_W = 62.36;
  const PLAQUE_H = 52.36;

  const pdf = new jsPDF({
    orientation: "landscape",
    unit: "mm",
    format: [PLAQUE_W, PLAQUE_H]
  });

  // Image brute
  const tmp = document.createElement("canvas");
  tmp.width = imgBitmap.width;
  tmp.height = imgBitmap.height;
  tmp.getContext("2d").drawImage(imgBitmap, 0, 0);

  const imgData = tmp.toDataURL("image/png");

  // Image EXACTEMENT √† l‚Äô√©chelle r√©elle 1:1
  pdf.addImage(imgData, "PNG", 0, 0, PLAQUE_W, PLAQUE_H);

  // Points (rep√®re visuel uniquement)
  pdf.setFontSize(3);
  points.forEach((p, i) => {
    const x_mm = (p.x_px / imgBitmap.width) * PLAQUE_W;
    const y_mm = PLAQUE_H - ((p.y_px / imgBitmap.height) * PLAQUE_H);
    pdf.text(String(i + 1), x_mm, y_mm);
  });

  pdf.save("PolarisVision_PDF_1to1_non_chirurgical.pdf");
};
</script>
</body>
</html>
